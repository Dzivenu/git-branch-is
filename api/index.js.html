<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: index.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: index.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @copyright Copyright 2016 Kevin Locke &lt;kevin@kevinlocke.name>
 * @license MIT
 */
'use strict';

var execFile = require('child_process').execFile;

/** Options for {@link gitBranchIs}.
 *
 * @typedef {{
 *   cwd: (?string|undefined),
 *   gitDir: (?string|undefined),
 *   gitPath: (string|undefined)
 * }}
 * @property {?string=} cwd Current working directory where the branch name is
 * tested.
 * @property {?string=} gitDir Path to the repository (i.e.
 * &lt;code>--git-dir=&lt;/code> option to &lt;code>git&lt;/code>).
 * @property {string=} git Git binary name or path to use (default:
 * &lt;code>'git'&lt;/code>).
 */
var GitBranchIsOptions = {
  cwd: '',
  gitDir: '',
  gitPath: 'git'
};

/** Checks that the current branch of a git repository has a given name.
 *
 * @param {string} branchName Expected name of current branch.
 * @param {?GitBranchIsOptions=} options Options.
 * @param {?function(Error, boolean=)=} callback Callback function called
 * with &lt;code>true&lt;/code> if the current branch is &lt;code>branchName&lt;/code>,
 * &lt;code>false&lt;/code> if not, &lt;code>Error&lt;/code> if it could not be determined.
 * @return {Promise|undefined} If &lt;code>callback&lt;/code> is not given and
 * &lt;code>global.Promise&lt;/code> is defined, a &lt;code>Promise&lt;/code> with
 * &lt;code>true&lt;/code> if the current branch is &lt;code>branchName&lt;/code>,
 * &lt;code>false&lt;/code> if not, &lt;code>Error&lt;/code> if it could not be determined.
 */
function gitBranchIs(branchName, options, callback) {
  if (!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }

  if (!callback &amp;&amp; typeof Promise === 'function') {
    // eslint-disable-next-line no-undef
    return new Promise(function(resolve, reject) {
      gitBranchIs(branchName, options, function(err, result) {
        if (err) { reject(err); } else { resolve(result); }
      });
    });
  }

  if (typeof callback !== 'function') {
    throw new TypeError('callback must be a function');
  }

  if (options &amp;&amp; typeof options !== 'object') {
    process.nextTick(function() {
      callback(new TypeError('options must be an object'));
    });
    return undefined;
  }

  gitBranchIs.getBranch(options, function(err, currentBranch) {
    if (err) {
      callback(err);
      return;
    }

    callback(null, branchName === currentBranch);
  });
  return undefined;
}

/** Checks that the current branch of a git repository has a given name.
 *
 * @param {?GitBranchIsOptions=} options Options.
 * @param {?function(Error, string=)=} callback Callback function called
 * with the current branch name, or &lt;code>Error&lt;/code> if it could not be
 * determined.
 * @return {Promise|undefined} If &lt;code>callback&lt;/code> is not given and
 * &lt;code>global.Promise&lt;/code> is defined, a &lt;code>Promise&lt;/code> with the
 * current branch name, or &lt;code>Error&lt;/code> if it could not be determined.
 */
gitBranchIs.getBranch = function getBranch(options, callback) {
  if (!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }

  if (!callback &amp;&amp; typeof Promise === 'function') {
    // eslint-disable-next-line no-undef
    return new Promise(function(resolve, reject) {
      getBranch(options, function(err, result) {
        if (err) { reject(err); } else { resolve(result); }
      });
    });
  }

  if (typeof callback !== 'function') {
    throw new TypeError('callback must be a function');
  }

  if (options &amp;&amp; typeof options !== 'object') {
    process.nextTick(function() {
      callback(new TypeError('options must be an Object'));
    });
    return undefined;
  }

  var combinedOpts = {};
  Object.keys(GitBranchIsOptions).forEach(function(prop) {
    combinedOpts[prop] = GitBranchIsOptions[prop];
  });
  Object.keys(Object(options)).forEach(function(prop) {
    combinedOpts[prop] = options[prop];
  });

  var gitArgs = ['symbolic-ref', '--short', 'HEAD'];
  if (combinedOpts.gitDir) {
    gitArgs.unshift('--git-dir=' + combinedOpts.gitDir);
  }

  try {
    execFile(
        combinedOpts.gitPath,
        gitArgs,
        {cwd: combinedOpts.cwd},
        function(errExec, stdout, stderr) {
          if (errExec) {
            callback(errExec);
            return;
          }

          // Note:  ASCII space and control characters are forbidden in names
          // https://www.kernel.org/pub/software/scm/git/docs/git-check-ref-format.html
          callback(null, stdout.trimRight());
        }
    );
  } catch (errExec) {
    process.nextTick(function() {
      callback(errExec);
    });
    return undefined;
  }

  return undefined;
};

module.exports = gitBranchIs;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#gitBranchIs">gitBranchIs</a></li><li><a href="global.html#gitBranchIsCmd">gitBranchIsCmd</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Fri Apr 01 2016 22:42:23 GMT-0700 (PDT)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
